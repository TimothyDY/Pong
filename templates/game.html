<!DOCTYPE html>
<html>
<head>
    <title>Game Room</title>
    
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <style>
      .wrap { max-width: 1400px; margin: 0 auto; color: var(--text); font-family: 'Orbitron', 'Share Tech Mono', monospace; text-transform: uppercase; letter-spacing: 1px; min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 16px; }
      .top { display:flex; align-items:center; justify-content:center; margin-bottom: 12px; width: 100%; }
      .status { font-size: 14px; color: var(--muted); }
      .game-container { display: flex; flex-direction: row; align-items: center; justify-content: center; gap: 20px; margin-top: 20px; }
      .pong-canvas { border: 3px solid var(--text); background: var(--bg); box-shadow: 0 0 30px rgba(255,255,255,.2); }
      .score-board { display: flex; justify-content: space-between; width: 800px; margin-bottom: 16px; }
      .score-item { background: var(--card); padding: 12px 20px; border: 2px solid var(--border); text-align: center; }
      .score-number { font-size: 32px; font-weight: bold; color: var(--text); font-family: 'Orbitron', monospace; }
      .controls-info { margin-top: 16px; text-align: center; color: var(--muted); font-size: 14px; }
      /* Keep control buttons consistent width */
      .panel .btn { min-width: 160px !important; width: 160px !important; }
      .panel .btn.secondary, .panel .btn.danger { min-width: 160px !important; width: 160px !important; }
      .controls-panel { background: var(--card); border: 2px solid var(--border); padding: 20px; margin: 16px 0; width: 250px; box-shadow: 0 0 15px rgba(255,255,255,.1); }
      .controls-grid { display: flex; flex-direction: column; gap: 20px; margin-top: 12px; }
      .control-item { text-align: center; padding: 12px; background: var(--bg); border: 2px solid var(--border); }
      .control-keys { font-size: 18px; font-weight: bold; color: var(--text); margin-bottom: 8px; font-family: 'Orbitron', monospace; }
      .control-label { color: var(--text); font-weight: 700; margin-bottom: 4px; font-family: 'Orbitron', monospace; }
      .control-desc { color: var(--muted); font-size: 12px; }
      .connection-status { display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; border-radius: 12px; font-size: 12px; font-weight: 600; }
      .connection-status.connected { background: var(--text); color: var(--bg); }
      .connection-status.disconnected { background: var(--bg); color: var(--text); border: 1px solid var(--border); }
      .status-dot { width: 8px; height: 8px; border-radius: 50%; }
      .status-dot.connected { background: var(--text); }
      .status-dot.disconnected { background: var(--muted); }
      .panel { margin-top: 16px; color: var(--text); display:flex; gap:8px; align-items:center; flex-wrap: wrap; justify-content: center; }
      .btn { padding: 10px 12px; background: var(--text); color: var(--bg); border: 2px solid var(--text); cursor: pointer; font-weight:700; font-family: 'Share Tech Mono', monospace; transition: all 0.3s ease; min-width: 160px !important; width: 160px !important; box-sizing: border-box; text-align: center; }
      .btn:disabled { background: var(--bg); color: var(--muted); cursor:not-allowed; border: 2px solid var(--border); }
      .btn.secondary { background: var(--bg); color: var(--text); border: 2px solid var(--border); }
      .btn.danger { background: var(--bg); color: var(--text); border: 2px solid var(--text); }
      .btn.success { background: var(--text); color: var(--bg); border: 2px solid var(--text); }
      .notice { margin-left: auto; color: var(--muted); }
      .rematch-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; }
      .rematch-content { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--card); padding: 24px; border: 2px solid var(--border); text-align: center; min-width: 300px; box-shadow: 0 0 20px rgba(255,255,255,.2); }
      .rematch-buttons { display: flex; gap: 12px; justify-content: center; margin-top: 16px; }
      .player-info { display: flex; gap: 16px; margin-bottom: 16px; justify-content: center; }
      .player-card { background: var(--card); padding: 12px; border: 2px solid var(--border); text-align: center; min-width: 120px; }
      .player-card.active { border-color: var(--text); color: var(--text); background: var(--card); box-shadow: 0 0 10px rgba(255,255,255,.3); }
      .flash-message { padding: 12px; margin-bottom: 16px; position: fixed; top: 20px; right: 20px; z-index: 1001; max-width: 300px; border: 2px solid var(--border); font-family: 'Share Tech Mono', monospace; }
      .flash-message.error { background: var(--bg); color: var(--text); border: 2px solid var(--text); }
      .flash-message.success { background: var(--text); color: var(--bg); border: 2px solid var(--text); }
      .flash-message.info { background: var(--card); color: var(--text); border: 2px solid var(--border); }
      
      /* Game button overlay styles */
      .game-button-overlay { 
        position: absolute; 
        top: 50%; 
        left: 50%; 
        transform: translate(-50%, -50%); 
        z-index: 100; 
        background: rgba(0, 0, 0, 0.8); 
        padding: 30px; 
        border-radius: 15px; 
        border: 2px solid var(--border);
        backdrop-filter: blur(5px);
        display: flex;
        flex-direction: column;
        gap: 15px;
        align-items: center;
        min-width: 300px;
      }
      .game-button-overlay .btn { 
        min-width: 160px !important; 
        width: 160px !important; 
        margin: 0;
      }
      .game-button-overlay .panel { 
        margin: 0; 
        flex-direction: column; 
        gap: 15px;
      }
    </style>
    
</head>
<body>
<div class="wrap">
  <div class="top" style="justify-content:center;">
    <div class="status">Room: <strong>{{ room_id }}</strong> â€¢ User: <strong>{{ username }}</strong></div>
  </div>
  
  <div class="player-info" id="playerInfo" style="display: none;"></div>
  
  <div class="game-container">
    <div style="display: flex; flex-direction: column; align-items: center;">
      <div id="gameStatus" style="color: var(--muted); font-size: 14px; margin-bottom: 10px; text-align: center;"></div>
      <div style="position:relative;">
        <div class="score-number" id="leftScoreMobile" style="position: absolute; left: -80px; top: 50%; transform: translateY(-50%); font-size: 48px;">0</div>
        <canvas class="pong-canvas" id="pongCanvas" width="800" height="600"></canvas>
        <div class="score-number" id="rightScoreMobile" style="position: absolute; right: -80px; top: 50%; transform: translateY(-50%); font-size: 48px;">0</div>
        <div id="gameOverlay" class="game-overlay"></div>
        
        <!-- Game button overlay -->
        <div id="gameButtonOverlay" class="game-button-overlay" style="display: none;">
          <div id="overlayTitle" style="font-size: 18px; font-weight: bold; margin-bottom: 10px; color: var(--text);"></div>
          <div class="panel">
            <button class="btn" id="btnStart">Start Game</button>
            <button class="btn secondary" id="btnRestart" style="display: none;">Restart</button>
            <button class="btn secondary" id="btnRematch" style="display: none;">Rematch</button>
            <button class="btn danger" id="btnDissolve" style="display: none;">Dissolve Room</button>
            <button class="btn secondary" id="btnLeave">Leave Room</button>
          </div>
          <span id="rematchInfo" class="notice"></span>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Rematch Modal -->
<div class="rematch-modal" id="rematchModal">
  <div class="rematch-content">
    <h3>Rematch Request</h3>
    <p id="rematchMessage">Room creator wants to play again!</p>
    <div class="rematch-buttons">
      <button class="btn success" id="btnAcceptRematch">Accept</button>
      <button class="btn secondary" id="btnDeclineRematch">Decline</button>
    </div>
  </div>
</div>

<script>
const socket = io();
const roomId = "{{ room_id }}";
// Autostart removed
const username = "{{ username }}";

let myPaddle = null; // 'left' | 'right'
let mode = 'pvp';
let gameState = {
  ball: { x: 400, y: 300, dx: 4, dy: 2 },
  paddles: { left: { y: 250 }, right: { y: 250 } },
  score: { left: 0, right: 0 }
};
let gameRunning = false;
let isRoomCreator = false;
let roomCreator = '';
let winPoints = 5;

const statusEl = document.getElementById('status');
const canvas = document.getElementById('pongCanvas');
const ctx = canvas.getContext('2d');
const rematchInfo = document.getElementById('rematchInfo');
const playerInfo = document.getElementById('playerInfo');
const playerLeftName = document.getElementById('playerLeftName');
const playerRightName = document.getElementById('playerRightName');
const btnStart = document.getElementById('btnStart');
const btnRematch = document.getElementById('btnRematch');
const btnRestart = document.getElementById('btnRestart');
const btnDissolve = document.getElementById('btnDissolve');
const rematchModal = document.getElementById('rematchModal');
const rematchMessage = document.getElementById('rematchMessage');
const scoreBoard = document.getElementById('scoreBoard');
const leftScore = document.getElementById('leftScore');
const rightScore = document.getElementById('rightScore');
const leftScoreMobile = document.getElementById('leftScoreMobile');
const rightScoreMobile = document.getElementById('rightScoreMobile');
const leftPlayerName = document.getElementById('leftPlayerName');
const rightPlayerName = document.getElementById('rightPlayerName');
const gameStatus = document.getElementById('gameStatus');
const gameButtonOverlay = document.getElementById('gameButtonOverlay');
// No overlay start; using bottom Start button

// Cursor-based controls only

function showFlashMessage(message, type = 'info') {
  const flash = document.createElement('div');
  flash.className = `flash-message ${type}`;
  flash.textContent = message;
  document.body.appendChild(flash);
  
  setTimeout(() => {
    flash.style.opacity = '0';
    flash.style.transition = 'opacity 0.3s ease';
    setTimeout(() => flash.remove(), 300);
  }, 3000);
}

function drawGame() {
  // Clear canvas
  // Retro green/black
  ctx.fillStyle = '#000000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw center line
  ctx.strokeStyle = '#124d26';
  ctx.lineWidth = 2;
  ctx.setLineDash([10, 10]);
  ctx.beginPath();
  ctx.moveTo(canvas.width / 2, 0);
  ctx.lineTo(canvas.width / 2, canvas.height);
  ctx.stroke();
  ctx.setLineDash([]);
  
  // Draw paddles
  ctx.fillStyle = '#00ff88';
  // Left paddle
  ctx.fillRect(10, gameState.paddles.left.y, 10, 80);  // Updated paddle height
  // Right paddle
  ctx.fillRect(canvas.width - 20, gameState.paddles.right.y, 10, 80);  // Updated paddle height
  
  // Draw ball
  ctx.fillStyle = '#00ff88';
  // square ball 16x16 centered at ball position
  ctx.fillRect(gameState.ball.x - 8, gameState.ball.y - 8, 16, 16);
  
  // Update score display in both side panels and mobile view
  if (leftScore) leftScore.textContent = gameState.score.left;
  if (rightScore) rightScore.textContent = gameState.score.right;
  if (leftScoreMobile) leftScoreMobile.textContent = gameState.score.left;
  if (rightScoreMobile) rightScoreMobile.textContent = gameState.score.right;
}

function updateStatus(winner) {
  if (winner === 'left' || winner === 'right') {
    // Overlay will handle the end screen
    return;
  }
  if (mode === 'bot') {
    if (statusEl) statusEl.textContent = '';
    gameStatus.textContent = '';
  } else if (gameRunning) {
    if (statusEl) statusEl.textContent = 'Game in progress';
    gameStatus.textContent = 'Game in progress';
  } else {
    if (statusEl) statusEl.textContent = 'Waiting for game to start';
    gameStatus.textContent = 'Waiting for game to start...';
  }
}

function updatePlayerCards() { /* player cards removed */ }

function showRematchModal(requestedBy) {
  rematchMessage.textContent = `${requestedBy} wants to play again!`;
  rematchModal.style.display = 'block';
}

function hideRematchModal() {
  rematchModal.style.display = 'none';
}

// Function to manage button overlay visibility
function updateButtonOverlay() {
  if (!gameButtonOverlay) return;
  
  // Show overlay when game is not running or when there's a winner
  const shouldShowOverlay = !gameRunning || (gameState && gameState.winner);
  
  if (shouldShowOverlay) {
    gameButtonOverlay.style.display = 'flex';
    
    // Set overlay title
    const overlayTitle = document.getElementById('overlayTitle');
    if (overlayTitle) {
      if (gameState && gameState.winner) {
        overlayTitle.textContent = 'Game Over';
      } else if (!gameRunning) {
        overlayTitle.textContent = 'Game Controls';
      }
    }
    
    // Update individual button visibility
    if (btnStart) {
      const canStart = (!gameRunning && !(gameState && gameState.winner)) && (isRoomCreator || (mode === 'bot' && myPaddle === 'right'));
      btnStart.style.display = canStart ? 'inline-block' : 'none';
    }
    
    if (btnRestart) {
      btnRestart.style.display = (mode === 'bot' && isRoomCreator) ? 'inline-block' : 'none';
    }
    
    if (btnRematch) {
      btnRematch.style.display = (mode === 'pvp' && isRoomCreator && gameState && gameState.winner) ? 'inline-block' : 'none';
    }
    
    if (btnDissolve) {
      btnDissolve.style.display = isRoomCreator ? 'inline-block' : 'none';
    }
    
    if (btnLeave) {
      btnLeave.style.display = 'inline-block'; // Always show leave button
    }
  } else {
    // Hide overlay during active gameplay
    gameButtonOverlay.style.display = 'none';
  }
}

// Sound functions
function playBounceSound() {
  const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT');
  audio.volume = 0.3;
  audio.play().catch(() => {});
}

function playScoreSound() {
  const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT');
  audio.volume = 0.5;
  audio.play().catch(() => {});
}

// Flash functions for scoring and winning
function flashScore(scoringSide) {
  const scoreElement = scoringSide === 'left' ? leftScoreMobile : rightScoreMobile;
  if (scoreElement) {
    // Gentle flash effect - not too bright or fast
    scoreElement.style.transition = 'all 0.3s ease';
    scoreElement.style.color = '#ffff00'; // Gentle yellow
    scoreElement.style.textShadow = '0 0 10px #ffff00';
    
    setTimeout(() => {
      scoreElement.style.color = '';
      scoreElement.style.textShadow = '';
    }, 800);
  }
  console.log('Flash score for:', scoringSide); // Debug
}

function flashWinner(winnerSide) {
  const scoreElement = winnerSide === 'left' ? leftScoreMobile : rightScoreMobile;
  if (scoreElement) {
    // Winner flash - slightly more noticeable but still gentle
    let flashCount = 0;
    const maxFlashes = 3;
    
    function flash() {
      if (flashCount < maxFlashes) {
        scoreElement.style.transition = 'all 0.4s ease';
        scoreElement.style.color = '#00ff00'; // Gentle green
        scoreElement.style.textShadow = '0 0 15px #00ff00';
        
        setTimeout(() => {
          scoreElement.style.color = '';
          scoreElement.style.textShadow = '';
          flashCount++;
          
          setTimeout(() => {
            if (flashCount < maxFlashes) {
              flash();
            }
          }, 400);
        }, 400);
      }
    }
    
    flash();
  }
  console.log('Flash winner for:', winnerSide); // Debug
}

// Mouse movement handler for paddle control
canvas.addEventListener('mousemove', (e) => {
  if (!gameRunning || !myPaddle) return;
  
  const rect = canvas.getBoundingClientRect();
  const y = e.clientY - rect.top;
  
  // Emit paddle movement to server
  socket.emit('pong_paddle_move', {
    room_id: roomId,
    y: y,
    height: canvas.height
  });
});

// Keyboard handlers removed

// Connection status management
function updateConnectionStatus(connected, text = '') {
  const statusEl = document.getElementById('connectionStatus');
  const dotEl = document.getElementById('statusDot');
  const textEl = document.getElementById('connectionText');
  if (!statusEl || !dotEl || !textEl) return; // elements not present in current layout
  if (connected) {
    statusEl.className = 'connection-status connected';
    dotEl.className = 'status-dot connected';
    textEl.textContent = text || 'Connected';
  } else {
    statusEl.className = 'connection-status disconnected';
    dotEl.className = 'status-dot disconnected';
    textEl.textContent = text || 'Disconnected';
  }
}

// Socket connection events
socket.on('connect', () => {
  updateConnectionStatus(true, 'Connected');
  console.log('Connected to server');
});

socket.on('disconnect', () => {
  updateConnectionStatus(false, 'Disconnected');
  console.log('Disconnected from server');
});

socket.on('connect_error', (error) => {
  updateConnectionStatus(false, 'Connection Error');
  console.error('Connection error:', error);
});

// Socket event handlers
socket.emit('join_room', { room_id: roomId });

// Initialize button overlay on page load
updateButtonOverlay();

socket.on('pong_init', (data) => {
  mode = data.mode || 'pvp';
  myPaddle = data.you || null;
  gameState = data.game_state || gameState;
  gameRunning = data.game_running || false;
  isRoomCreator = data.is_creator || false;
  roomCreator = data.room_creator || '';
  winPoints = data.win_points || 5;
  
  // Controls panels removed; update controls
  // Show appropriate button based on mode
  if (btnRestart && btnRematch) {
    if (mode === 'bot') {
      btnRestart.style.display = isRoomCreator ? 'inline-block' : 'none';
      btnRematch.style.display = 'none';
    } else {
      btnRestart.style.display = 'none';
      btnRematch.style.display = isRoomCreator ? 'inline-block' : 'none';
    }
  }
  
  drawGame();
  updateStatus(data.winner || null);
  updatePlayerCards();
  
  // Update button overlay visibility
  updateButtonOverlay();
  
  if (data.winner) {
    rematchInfo.textContent = 'Game finished.';
  } else {
    rematchInfo.textContent = '';
  }
});

socket.on('players_update', (data) => {
  // Update player names
  if (data.players.left) {
    if (playerLeftName) playerLeftName.textContent = data.players.left;
    if (leftPlayerName) leftPlayerName.textContent = data.players.left;
  }
  if (data.players.right) {
    if (playerRightName) playerRightName.textContent = data.players.right;
    if (rightPlayerName) rightPlayerName.textContent = data.players.right;
  }
  
  // Show score elements
  if (leftScoreMobile) leftScoreMobile.style.display = 'block';
  if (rightScoreMobile) rightScoreMobile.style.display = 'block';
  
  // Update room creator info
  roomCreator = data.room_creator || '';
  isRoomCreator = username === roomCreator;
  
  // Update button overlay visibility
  updateButtonOverlay();
});

socket.on('pong_update', (data) => {
  const oldBallX = gameState.ball.x;
  const oldBallY = gameState.ball.y;
  
  gameState = data.game_state || gameState;
  
  // Check for ball bounce (collision with paddles or walls) - updated for new dimensions
  const ballHitPaddle = (oldBallX <= 20 && gameState.ball.x > 20) || 
                       (oldBallX >= 760 && gameState.ball.x < 760);  // Updated for 800 width
  const ballHitWall = (oldBallY <= 8 && gameState.ball.y > 8) || 
                      (oldBallY >= 592 && gameState.ball.y < 592);  // Updated for 600 height
  
  if (ballHitPaddle || ballHitWall) {
    playBounceSound();
  }
  
  drawGame();
});

socket.on('pong_score', (data) => {
  const scoringSide = data.scoring_side;
  
  // Flash the scoring side's score
  flashScore(scoringSide);
  
  // Play score sound
  playScoreSound();
  
  // Show scoring message
  if (gameStatus) {
    gameStatus.textContent = `${scoringSide === 'left' ? 'Left' : 'Right'} scored!`;
    setTimeout(() => {
      if (gameStatus) gameStatus.textContent = 'Game in progress';
    }, 1000);
  }
  
  // Update game state after a short delay to show the flash
  setTimeout(() => {
    gameState = data.game_state || gameState;
    drawGame();
  }, 100);
});

socket.on('pong_paddle_update', (data) => {
  if (data.paddle && gameState.paddles[data.paddle]) {
    gameState.paddles[data.paddle].y = data.y;
    drawGame();
  }
});

socket.on('pong_game_started', (data) => {
  gameRunning = true;
  gameState = data.game_state || gameState;
  drawGame();
  updateStatus();
  // Show start message above the canvas
  if (gameStatus) gameStatus.textContent = 'Game started! Good luck!';
  // Update button overlay visibility
  updateButtonOverlay();
});

socket.on('pong_game_over', (data) => {
  gameRunning = false;
  gameState = data.game_state || gameState;
  updateStatus(data.winner);
  
  // Flash the winner's side
  if (data.winner) {
    flashWinner(data.winner);
  }
  
  const overlay = document.getElementById('gameOverlay');
  if (overlay) {
    overlay.style.display = 'flex';
    overlay.textContent = 'Game Finished';
  }
  
  // Update button overlay visibility
  updateButtonOverlay();
  
  drawGame();
});

socket.on('rematch_requested', (data) => {
  if (!isRoomCreator) {
    showRematchModal(data.requested_by);
    rematchInfo.textContent = 'Rematch requested. Please respond.';
  }
});

socket.on('rematch_status', (d) => {
  const votes = d.votes || [];
  const pending = d.pending || [];
  rematchInfo.textContent = `Rematch votes: ${votes.join(', ')} | Pending: ${pending.join(', ')}`;
});

socket.on('rematch_declined', (data) => {
  rematchInfo.textContent = `${data.declined_by} declined rematch.`;
  hideRematchModal();
});

socket.on('pong_reset', (data) => {
  gameState = data.game_state || gameState;
  gameRunning = false;
  drawGame();
  updateStatus(null);
  updatePlayerCards();
  const overlay = document.getElementById('gameOverlay');
  if (overlay) overlay.style.display = 'none';
  if (gameStatus) gameStatus.textContent = 'Game reset! Good luck!';
  if (rematchInfo) rematchInfo.textContent = '';
  hideRematchModal();
  // Update button overlay visibility
  updateButtonOverlay();
});

socket.on('room_dissolved', () => {
  showFlashMessage('Room dissolved by creator', 'info');
  setTimeout(() => {
    window.location.href = '/dashboard';
  }, 2000);
});

socket.on('error', (e) => {
  showFlashMessage(e.message || 'Error occurred', 'error');
});

// Button event listeners
document.addEventListener('DOMContentLoaded', () => {
  const btnStart = document.getElementById('btnStart');
  const btnRestart = document.getElementById('btnRestart');
  const btnRematch = document.getElementById('btnRematch');
  const btnDissolve = document.getElementById('btnDissolve');
  const btnLeave = document.getElementById('btnLeave');
  const btnAcceptRematch = document.getElementById('btnAcceptRematch');
  const btnDeclineRematch = document.getElementById('btnDeclineRematch');
  
  if (btnStart) {
    btnStart.addEventListener('click', () => {
      // Always ask server to start; server will enforce permissions
      socket.emit('pong_start_game', { room_id: roomId });
      if (gameStatus) gameStatus.textContent = 'Starting game...';
    });
  }

  // No overlay start button handler
  
  if (btnRestart) {
    btnRestart.addEventListener('click', () => {
      // Restart for bot mode only
      gameRunning = false;
      gameState = {
        ball: { x: 400, y: 300, dx: 4, dy: 2 },  // Updated center position
        paddles: { left: { y: 250 }, right: { y: 250 } },  // Updated center position
        score: { left: 0, right: 0 }
      };
      drawGame();
      const overlay = document.getElementById('gameOverlay');
      if (overlay) overlay.style.display = 'none';
      if (gameStatus) gameStatus.textContent = 'Game restarted! Good luck!';
      if (rematchInfo) rematchInfo.textContent = '';
      // Update button overlay visibility
      updateButtonOverlay();
    });
  }
  
  if (btnRematch) {
    btnRematch.addEventListener('click', () => {
      // Rematch for PvP mode only
      socket.emit('pong_rematch_request', { room_id: roomId });
      if (rematchInfo) rematchInfo.textContent = 'Waiting for other player...';
    });
  }
  
  if (btnDissolve) {
    btnDissolve.addEventListener('click', () => {
      if (confirm('Are you sure you want to dissolve this room? All players will be disconnected.')) {
        socket.emit('dissolve_room', { room_id: roomId });
      }
    });
  }
  
  if (btnLeave) {
    btnLeave.addEventListener('click', () => {
      socket.emit('leave_room', { room_id: roomId });
      window.location.href = '/dashboard';
    });
  }
  
  if (btnAcceptRematch) {
    btnAcceptRematch.addEventListener('click', () => {
      socket.emit('pong_rematch_response', { 
        room_id: roomId, 
        response: 'accept' 
      });
      hideRematchModal();
      if (rematchInfo) rematchInfo.textContent = 'Rematch accepted!';
    });
  }
  
  if (btnDeclineRematch) {
    btnDeclineRematch.addEventListener('click', () => {
      socket.emit('pong_rematch_response', {
        room_id: roomId,
        response: 'decline'
      });
      hideRematchModal();
      if (rematchInfo) rematchInfo.textContent = 'Rematch declined';
    });
  }
});

// Initial canvas draw
drawGame();

// Close modal when clicking outside
rematchModal.addEventListener('click', (e) => {
  if (e.target === rematchModal) {
    hideRematchModal();
  }
});
</script>
</body>
</html>
